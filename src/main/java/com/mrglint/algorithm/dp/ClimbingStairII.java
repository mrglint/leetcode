package com.mrglint.algorithm.dp;

/**
 * @author luhuancheng
 * @since 2019-12-05 22:00
 */
public class ClimbingStairII {

    /**
     * 给定n级台阶，每一次可以走1、2、3步台阶，且每一次走动不能是相同步数
     * @param n 一共多少级台阶
     * @return
     */
    public int climbingStair(int n) {
        // 需要走到n级台阶，那么总共的可能是：
        // 1. 从n - 1级走1级到达n级
        // 2. 从n - 2级走2级到达n级
        // 3. 从n - 3级走3级到达n级
        // f(n) = f(n - 1) + f(n - 2) + f(n - 3)


        // 定义状态
        // 不能是相邻步数，说明：
        // 1. 走到n - 1步阶梯时，所用步数只能是2、3
        // 2. 走到n - 2步阶梯时，所用步数只能是1、3
        // 3. 走到n - 3步阶梯时，所用步数只能是1、2

        // 递推公式
        // dp[i][1] = dp[i - 1][2] + dp[i - 1][3]
        // dp[i][2] = dp[i - 1][1] + dp[i - 1][3]
        // dp[i][3] = dp[i - 1][1] + dp[i - 1][2]
        // 第一维记录步数
        int[][] dp = new int[n + 1][3];

        // 初始状态
        // 台阶数为1时，最后一步为1步，可走的种数：走1步到达
        dp[1][1] = 1;
        // 台阶数为2时，最后一步为2步，可走的种数：走2步到达
        dp[2][2] = 1;
        // 台阶数为3时，最后一步为1步，可走的种数：先走2步再走1步到达
        dp[3][1] = 1;
        // 台阶数为3时，最后一步为2步，可走的种数：先走1步再走2步到达
        dp[3][2] = 1;
        // 台阶数为3时，最后一步为3步，可走的种数：走3步到达
        dp[3][3] = 1;

        for (int i = 4; i <= n; i++) {
            // 最后走1步到达的种数
            dp[i][1] = dp[i - 1][2] + dp[i - 1][3];
            // 最后走2步到达的种数
            dp[i][2] = dp[i - 2][1] + dp[i - 2][3];
            // 最后走3步到达的种数
            dp[i][3] = dp[i - 3][1] + dp[i - 3][2];
        }
        return dp[n][1] + dp[n][2] + dp[n][3];
    }
}
